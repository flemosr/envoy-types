// This file is @generated by prost-build.
/// Configuration for the transform filter. The filter may buffer the request/response until the
/// entire body is received, and then mutate the headers and body according to the contents
/// of the request/response. The request and response transformations are independent and could
/// be configured separately.
/// Only JSON body transformation is supported for now.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformConfig {
    /// Configuration for transforming request.
    ///
    /// .. note::
    ///
    /// If set then the entire request headers and body will always be buffered on a JSON request
    /// even if only headers are transformed.
    #[prost(message, optional, tag = "1")]
    pub request_transformation: ::core::option::Option<Transformation>,
    /// Configuration for transforming response.
    ///
    /// .. note::
    ///
    /// If set then the entire response headers and body will always be buffered on a JSON response
    /// even if only headers are transformed.
    #[prost(message, optional, tag = "2")]
    pub response_transformation: ::core::option::Option<Transformation>,
    ///
    /// If true and the request headers are transformed, Envoy will re-evaluate the target
    /// cluster in the same route. Please ensure the cluster specifier in the route supports
    /// dynamic evaluation or this flag will have no effect, e.g.
    /// : ref:`matcher cluster specifier  <envoy_v3_api_msg_extensions.router.cluster_specifiers.matcher.v3.MatcherClusterSpecifier>`.
    ///
    ///
    /// Only one of `clear_cluster_cache` and `clear_route_cache` can be true.
    #[prost(bool, tag = "3")]
    pub clear_cluster_cache: bool,
    /// If true and the request headers are transformed, Envoy will clear the route cache for
    /// the current request and force re-evaluation of the route. This has performance penalty and
    /// should only be used when the route match criteria depends on the transformed headers.
    ///
    /// Only one of `clear_cluster_cache` and `clear_route_cache` can be true.
    #[prost(bool, tag = "4")]
    pub clear_route_cache: bool,
}
impl ::prost::Name for TransformConfig {
    const NAME: &'static str = "TransformConfig";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.transform.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.transform.v3.TransformConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.transform.v3.TransformConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transformation {
    /// The header mutations to perform.
    /// The :ref:`substitution format specifier <config_access_log_format>` could be applied here.
    /// In addition to the commonly used format specifiers, this filter introduces additional format specifiers:
    ///
    /// * `%REQUEST_BODY(KEY*)%`: the request body. And `Key` KEY is an optional
    ///   lookup key in the namespace with the option of specifying nested keys separated by ':'.
    /// * `%RESPONSE_BODY(KEY*)%`: the response body. And `Key` KEY is an optional
    ///   lookup key in the namespace with the option of specifying nested keys separated by ':'.
    #[prost(message, repeated, tag = "1")]
    pub headers_mutations: ::prost::alloc::vec::Vec<
        super::super::super::super::super::config::common::mutation_rules::v3::HeaderMutation,
    >,
    /// The body transformation configuration. If not set, no body transformation will be performed.
    #[prost(message, optional, tag = "2")]
    pub body_transformation: ::core::option::Option<BodyTransformation>,
}
impl ::prost::Name for Transformation {
    const NAME: &'static str = "Transformation";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.transform.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.transform.v3.Transformation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.transform.v3.Transformation"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BodyTransformation {
    /// Body transformation configuration. The substitution format string is used as the template
    /// to generate the transformed new body content.
    /// The :ref:`substitution format specifier <config_access_log_format>` could be applied here.
    /// And except the commonly used format specifiers, the additional format specifiers
    /// `%REQUEST_BODY(KEY*)%` and `%RESPONSE_BODY(KEY*)%` could also be used here.
    #[prost(message, optional, tag = "1")]
    pub body_format: ::core::option::Option<
        super::super::super::super::super::config::core::v3::SubstitutionFormatString,
    >,
    /// The action to perform for new body content and original body content.
    /// For example, if `MERGE` is used, then the new body content generated from the `body_format`
    /// will be merged into the original body content.
    ///
    /// Default is `MERGE`.
    #[prost(enumeration = "body_transformation::TransformAction", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `BodyTransformation`.
pub mod body_transformation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransformAction {
        /// Merge the transformed body with the original body. This is the default action.
        Merge = 0,
        /// Replace the original body with the transformed body.
        Replace = 1,
    }
    impl TransformAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Merge => "MERGE",
                Self::Replace => "REPLACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MERGE" => Some(Self::Merge),
                "REPLACE" => Some(Self::Replace),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BodyTransformation {
    const NAME: &'static str = "BodyTransformation";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.transform.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.transform.v3.BodyTransformation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.transform.v3.BodyTransformation"
            .into()
    }
}
