// This file is @generated by prost-build.
///
/// Specifies that matching should be performed by the endpoint metadata.
/// This input extracts metadata from the selected endpoint for transport socket selection.
/// The metadata is extracted using a filter and path specification similar to
/// : ref:`DynamicMetadataInput <envoy_v3_api_msg_extensions.matching.common_inputs.network.v3.DynamicMetadataInput>`.
///
///
/// Example: Extract a metadata value for transport socket matching.
///
/// .. code-block:: yaml
///
/// typed_config:
/// "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.EndpointMetadataInput
/// filter: "envoy.transport_socket_match"
/// path:
/// - key: "socket_type"
///
/// This configuration extracts the value at path `["envoy.transport_socket_match"]["socket_type"]`
/// from the endpoint metadata for use in transport socket selection.
///
/// \[\#extension: envoy.matching.inputs.endpoint_metadata\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointMetadataInput {
    /// The filter name to retrieve the Struct from the endpoint metadata.
    /// If not specified, defaults to `envoy.lb` which is commonly used for load balancing metadata.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The path to retrieve the Value from the Struct.
    #[prost(message, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<endpoint_metadata_input::PathSegment>,
}
/// Nested message and enum types in `EndpointMetadataInput`.
pub mod endpoint_metadata_input {
    /// Specifies the segment in a path to retrieve value from Metadata.
    /// Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
    /// if the segment key refers to a list, it has to be the last segment in a path.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PathSegment {
        #[prost(oneof = "path_segment::Segment", tags = "1")]
        pub segment: ::core::option::Option<path_segment::Segment>,
    }
    /// Nested message and enum types in `PathSegment`.
    pub mod path_segment {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Segment {
            /// If specified, use the key to retrieve the value in a Struct.
            #[prost(string, tag = "1")]
            Key(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for PathSegment {
        const NAME: &'static str = "PathSegment";
        const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.matching.common_inputs.transport_socket.v3.EndpointMetadataInput.PathSegment"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.EndpointMetadataInput.PathSegment"
                .into()
        }
    }
}
impl ::prost::Name for EndpointMetadataInput {
    const NAME: &'static str = "EndpointMetadataInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.transport_socket.v3.EndpointMetadataInput"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.EndpointMetadataInput"
            .into()
    }
}
///
/// Specifies that matching should be performed by the locality metadata.
/// This input extracts metadata from the endpoint's locality for transport socket selection.
/// The metadata is extracted using a filter and path specification similar to
/// : ref:`DynamicMetadataInput <envoy_v3_api_msg_extensions.matching.common_inputs.network.v3.DynamicMetadataInput>`.
///
///
/// Example: Extract a metadata value from locality for transport socket matching.
///
/// .. code-block:: yaml
///
/// typed_config:
/// "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.LocalityMetadataInput
/// filter: "envoy.transport_socket_match"
/// path:
/// - key: "region"
///
/// This configuration extracts the value at path `["envoy.transport_socket_match"]["region"]`
/// from the locality metadata for use in transport socket selection.
///
/// \[\#extension: envoy.matching.inputs.locality_metadata\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalityMetadataInput {
    /// The filter name to retrieve the Struct from the locality metadata.
    /// If not specified, defaults to `envoy.lb` which is commonly used for load balancing metadata.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The path to retrieve the Value from the Struct.
    #[prost(message, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<locality_metadata_input::PathSegment>,
}
/// Nested message and enum types in `LocalityMetadataInput`.
pub mod locality_metadata_input {
    /// Specifies the segment in a path to retrieve value from Metadata.
    /// Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
    /// if the segment key refers to a list, it has to be the last segment in a path.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PathSegment {
        #[prost(oneof = "path_segment::Segment", tags = "1")]
        pub segment: ::core::option::Option<path_segment::Segment>,
    }
    /// Nested message and enum types in `PathSegment`.
    pub mod path_segment {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Segment {
            /// If specified, use the key to retrieve the value in a Struct.
            #[prost(string, tag = "1")]
            Key(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for PathSegment {
        const NAME: &'static str = "PathSegment";
        const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.matching.common_inputs.transport_socket.v3.LocalityMetadataInput.PathSegment"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.LocalityMetadataInput.PathSegment"
                .into()
        }
    }
}
impl ::prost::Name for LocalityMetadataInput {
    const NAME: &'static str = "LocalityMetadataInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.transport_socket.v3.LocalityMetadataInput"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.LocalityMetadataInput"
            .into()
    }
}
/// Specifies that matching should be performed by filter state.
/// This input extracts a value from filter state that was explicitly shared from the
/// downstream connection to the upstream connection via `TransportSocketOptions`.
/// This enables flexible downstream-connection-based transport socket selection,
/// such as matching on network namespace or any custom filter state data.
///
/// Example: Match on network namespace stored in filter state.
///
/// .. code-block:: yaml
///
/// typed_config:
/// "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.FilterStateInput
/// key: "envoy.network.namespace"
///
/// \[\#extension: envoy.matching.inputs.transport_socket_filter_state\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FilterStateInput {
    /// The key of the filter state object to retrieve.
    /// The object must implement serializeAsString() to be used for matching.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for FilterStateInput {
    const NAME: &'static str = "FilterStateInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.transport_socket.v3.FilterStateInput"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.FilterStateInput"
            .into()
    }
}
/// Configuration for the transport socket name action.
/// This action sets the name of the transport socket to use when the matcher matches.
/// \[\#extension: envoy.matching.action.transport_socket.name\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransportSocketNameAction {
    /// The name of the transport socket to use.
    /// This name must reference a named transport socket in the cluster's transport_socket_matches.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for TransportSocketNameAction {
    const NAME: &'static str = "TransportSocketNameAction";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.transport_socket.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.transport_socket.v3.TransportSocketNameAction"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.transport_socket.v3.TransportSocketNameAction"
            .into()
    }
}
