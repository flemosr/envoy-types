// This file is @generated by prost-build.
/// \[\#next-free-field: 7\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyProtocol {
    /// The list of rules to apply to requests.
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<proxy_protocol::Rule>,
    /// Allow requests through that don't use proxy protocol. Defaults to false.
    ///
    /// .. attention::
    ///
    /// This breaks conformance with the specification.
    /// Only enable if ALL traffic to the listener comes from a trusted source.
    /// For more information on the security implications of this feature, see
    /// <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>
    ///
    /// .. attention::
    ///
    /// Requests of 12 or fewer bytes that match the proxy protocol v2 signature
    /// and requests of 6 or fewer bytes that match the proxy protocol v1
    /// signature will timeout (Envoy is unable to differentiate these requests
    /// from incomplete proxy protocol requests).
    #[prost(bool, tag = "2")]
    pub allow_requests_without_proxy_protocol: bool,
    /// This config controls which TLVs can be passed to filter state if it is Proxy Protocol
    /// V2 header. If there is no setting for this field, no TLVs will be passed through.
    ///
    /// .. note::
    ///
    ///
    /// If this is configured, you likely also want to set
    /// : ref:`core.v3.ProxyProtocolConfig.pass_through_tlvs <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`,
    ///   which controls pass-through for the upstream.
    #[prost(message, optional, tag = "3")]
    pub pass_through_tlvs: ::core::option::Option<
        super::super::super::super::super::config::core::v3::ProxyProtocolPassThroughTlVs,
    >,
    /// The PROXY protocol versions that won't be matched. Useful to limit the scope and attack surface of the filter.
    ///
    /// When the filter receives PROXY protocol data that is disallowed, it will reject the connection.
    /// By default, the filter will match all PROXY protocol versions.
    /// See <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt> for details.
    ///
    /// .. attention::
    ///
    /// When used in conjunction with the :ref:`allow_requests_without_proxy_protocol <envoy_v3_api_field_extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.allow_requests_without_proxy_protocol>`,
    /// the filter will not attempt to match signatures for the disallowed versions.
    /// For example, when `disallowed_versions=V2`, `allow_requests_without_proxy_protocol=true`,
    /// and an incoming request matches the V2 signature, the filter will allow the request through without any modification.
    /// The filter treats this request as if it did not have any PROXY protocol information.
    #[prost(
        enumeration = "super::super::super::super::super::config::core::v3::proxy_protocol_config::Version",
        repeated,
        tag = "4"
    )]
    pub disallowed_versions: ::prost::alloc::vec::Vec<i32>,
    /// The human readable prefix to use when emitting statistics for the filter.
    /// If not configured, statistics will be emitted without the prefix segment.
    /// See the :ref:`filter's statistics documentation <config_listener_filters_proxy_protocol>` for
    /// more information.
    #[prost(string, tag = "5")]
    pub stat_prefix: ::prost::alloc::string::String,
    /// Controls where TLV values are stored when rules match. Defaults to DYNAMIC_METADATA.
    #[prost(enumeration = "proxy_protocol::TlvLocation", tag = "6")]
    pub tlv_location: i32,
}
/// Nested message and enum types in `ProxyProtocol`.
pub mod proxy_protocol {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeyValuePair {
        /// The namespace â€” if this is empty, the filter's namespace will be used.
        #[prost(string, tag = "1")]
        pub metadata_namespace: ::prost::alloc::string::String,
        /// The key to use within the namespace.
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
    }
    impl ::prost::Name for KeyValuePair {
        const NAME: &'static str = "KeyValuePair";
        const PACKAGE: &'static str = "envoy.extensions.filters.listener.proxy_protocol.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair"
                .into()
        }
    }
    /// A Rule defines what metadata to apply when a header is present or missing.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Rule {
        /// The type that triggers the rule - required
        /// TLV type is defined as uint8_t in proxy protocol. See `the spec  <<https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>`\_> for details.
        #[prost(uint32, tag = "1")]
        pub tlv_type: u32,
        /// If the TLV type is present, apply this metadata KeyValuePair.
        #[prost(message, optional, tag = "2")]
        pub on_tlv_present: ::core::option::Option<KeyValuePair>,
    }
    impl ::prost::Name for Rule {
        const NAME: &'static str = "Rule";
        const PACKAGE: &'static str = "envoy.extensions.filters.listener.proxy_protocol.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule"
                .into()
        }
    }
    /// Controls where TLV values are stored when rules match.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlvLocation {
        /// Store TLV values in dynamic metadata.
        DynamicMetadata = 0,
        /// Store TLV values in filter state as a single map-like object.
        FilterState = 1,
    }
    impl TlvLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DynamicMetadata => "DYNAMIC_METADATA",
                Self::FilterState => "FILTER_STATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DYNAMIC_METADATA" => Some(Self::DynamicMetadata),
                "FILTER_STATE" => Some(Self::FilterState),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ProxyProtocol {
    const NAME: &'static str = "ProxyProtocol";
    const PACKAGE: &'static str = "envoy.extensions.filters.listener.proxy_protocol.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol"
            .into()
    }
}
