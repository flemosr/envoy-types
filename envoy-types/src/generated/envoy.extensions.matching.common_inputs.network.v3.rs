// This file is @generated by prost-build.
/// Specifies that matching should be performed by the destination IP address.
/// \[\#extension: envoy.matching.inputs.destination_ip\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestinationIpInput {}
impl ::prost::Name for DestinationIpInput {
    const NAME: &'static str = "DestinationIPInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput"
            .into()
    }
}
/// Specifies that matching should be performed by the destination port.
/// \[\#extension: envoy.matching.inputs.destination_port\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestinationPortInput {}
impl ::prost::Name for DestinationPortInput {
    const NAME: &'static str = "DestinationPortInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput"
            .into()
    }
}
/// Specifies that matching should be performed by the source IP address.
/// \[\#extension: envoy.matching.inputs.source_ip\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourceIpInput {}
impl ::prost::Name for SourceIpInput {
    const NAME: &'static str = "SourceIPInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.SourceIPInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.SourceIPInput"
            .into()
    }
}
/// Specifies that matching should be performed by the source port.
/// \[\#extension: envoy.matching.inputs.source_port\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourcePortInput {}
impl ::prost::Name for SourcePortInput {
    const NAME: &'static str = "SourcePortInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.SourcePortInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.SourcePortInput"
            .into()
    }
}
/// Input that matches by the directly connected source IP address (this
/// will only be different from the source IP address when using a listener
/// filter that overrides the source address, such as the :ref:`Proxy Protocol  listener filter <config_listener_filters_proxy_protocol>`).
/// \[\#extension: envoy.matching.inputs.direct_source_ip\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DirectSourceIpInput {}
impl ::prost::Name for DirectSourceIpInput {
    const NAME: &'static str = "DirectSourceIPInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput"
            .into()
    }
}
/// Input that matches by the source IP type.
/// Specifies the source IP match type. The values include:
///
/// * `local` - matches a connection originating from the same host,
///   \[\#extension: envoy.matching.inputs.source_type\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourceTypeInput {}
impl ::prost::Name for SourceTypeInput {
    const NAME: &'static str = "SourceTypeInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput"
            .into()
    }
}
///
/// Input that matches by the requested server name (e.g. SNI in TLS).
/// : ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides the requested server name based on SNI,
///   when TLS protocol is detected.
///   \[\#extension: envoy.matching.inputs.server_name\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerNameInput {}
impl ::prost::Name for ServerNameInput {
    const NAME: &'static str = "ServerNameInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.ServerNameInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.ServerNameInput"
            .into()
    }
}
/// Input that matches by the transport protocol.
///
/// Suggested values include:
///
/// * `raw_buffer` - default, used when no transport protocol is detected,
/// * `tls` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
///   when TLS protocol is detected.
///   \[\#extension: envoy.matching.inputs.transport_protocol\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransportProtocolInput {}
impl ::prost::Name for TransportProtocolInput {
    const NAME: &'static str = "TransportProtocolInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput"
            .into()
    }
}
/// List of quoted and comma-separated requested application protocols. The list consists of a
/// single negotiated application protocol once the network stream is established.
///
/// Examples:
///
/// * `'h2','http/1.1'`
/// * `'h2c'`
///
/// Suggested values in the list include:
///
/// * `http/1.1` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>` and :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`,
/// * `h2` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
/// * `h2c` - set by :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`
///
/// .. attention::
///
/// Currently, :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
/// application protocol detection based on the requested
/// `ALPN <<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`\_> values.
///
/// However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
/// and matching on values other than `h2` is going to lead to a lot of false negatives,
/// unless all connecting clients are known to use ALPN.
/// \[\#extension: envoy.matching.inputs.application_protocol\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplicationProtocolInput {}
impl ::prost::Name for ApplicationProtocolInput {
    const NAME: &'static str = "ApplicationProtocolInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput"
            .into()
    }
}
/// Input that matches by a specific filter state key.
/// The value of the provided filter state key will be the raw string representation of the filter state object
/// \[\#extension: envoy.matching.inputs.filter_state\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FilterStateInput {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for FilterStateInput {
    const NAME: &'static str = "FilterStateInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.FilterStateInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.FilterStateInput"
            .into()
    }
}
///
/// Input that matches dynamic metadata by key.
/// DynamicMetadataInput provides a general interface using `filter` and `path` to retrieve value from
/// : ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`.
///
///
/// For example, for the following Metadata:
///
/// .. code-block:: yaml
///
/// ```text
/// filter_metadata:
///   envoy.xxx:
///     prop:
///       foo: bar
///       xyz:
///         hello: envoy
/// ```
///
/// The following DynamicMetadataInput will retrieve a string value "bar" from the Metadata.
///
/// .. code-block:: yaml
///
/// ```text
/// filter: envoy.xxx
/// path:
/// - key: prop
/// - key: foo
/// ```
///
/// \[\#extension: envoy.matching.inputs.dynamic_metadata\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicMetadataInput {
    /// The filter name to retrieve the Struct from the Metadata.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The path to retrieve the Value from the Struct.
    #[prost(message, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<dynamic_metadata_input::PathSegment>,
}
/// Nested message and enum types in `DynamicMetadataInput`.
pub mod dynamic_metadata_input {
    /// Specifies the segment in a path to retrieve value from Metadata.
    /// Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
    /// if the segment key refers to a list, it has to be the last segment in a path.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PathSegment {
        #[prost(oneof = "path_segment::Segment", tags = "1")]
        pub segment: ::core::option::Option<path_segment::Segment>,
    }
    /// Nested message and enum types in `PathSegment`.
    pub mod path_segment {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Segment {
            /// If specified, use the key to retrieve the value in a Struct.
            #[prost(string, tag = "1")]
            Key(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for PathSegment {
        const NAME: &'static str = "PathSegment";
        const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment"
                .into()
        }
    }
}
impl ::prost::Name for DynamicMetadataInput {
    const NAME: &'static str = "DynamicMetadataInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput"
            .into()
    }
}
///
/// Input that matches by the network namespace of the listener address.
/// This input returns the network namespace filepath that was used to create the listening socket.
/// On Linux systems, this corresponds to the `network_namespace_filepath` field in the
/// : ref:`SocketAddress <envoy_v3_api_msg_config.core.v3.SocketAddress>` configuration.
///
///
/// .. note::
///
/// This input is only meaningful on Linux systems where network namespaces are supported.
/// On other platforms, this input will always return an empty value.
///
/// \[\#extension: envoy.matching.inputs.network_namespace\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkNamespaceInput {}
impl ::prost::Name for NetworkNamespaceInput {
    const NAME: &'static str = "NetworkNamespaceInput";
    const PACKAGE: &'static str = "envoy.extensions.matching.common_inputs.network.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.matching.common_inputs.network.v3.NetworkNamespaceInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.NetworkNamespaceInput"
            .into()
    }
}
