// This file is @generated by prost-build.
/// This filter will inspect and get attributes from MCP traffic.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mcp {
    /// Configures how the filter handles non-MCP traffic.
    #[prost(enumeration = "mcp::TrafficMode", tag = "1")]
    pub traffic_mode: i32,
    /// When set to true, the filter will clear the route cache after setting dynamic metadata.
    /// This allows the route to be re-selected based on the MCP metadata (e.g., method, params).
    /// Defaults to false.
    #[prost(bool, tag = "2")]
    pub clear_route_cache: bool,
    /// Maximum size of the request body to buffer for JSON-RPC validation.
    /// If the request body exceeds this size, the request is rejected with `413 Payload Too Large`.
    /// This limit applies to both `REJECT_NO_MCP` and `PASS_THROUGH` modes to prevent unbounded buffering.
    ///
    /// It defaults to 8KB (8192 bytes) and the maximum allowed value is 10MB (10485760 bytes).
    ///
    /// Setting it to 0 would disable the limit. It is not recommended to do so in production.
    #[prost(message, optional, tag = "3")]
    pub max_request_body_size: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::UInt32Value,
    >,
    /// Parser configuration, this provide the attribute extraction override.
    #[prost(message, optional, tag = "4")]
    pub parser_config: ::core::option::Option<ParserConfig>,
}
/// Nested message and enum types in `Mcp`.
pub mod mcp {
    /// Traffic handling mode for non-MCP traffic.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrafficMode {
        /// Proxies the HTTP request and response without MCP spec check.
        /// This is the default mode.
        PassThrough = 0,
        /// Reject requests that are not following MCP spec.
        /// Valid MCP requests are:
        ///
        /// * POST requests with JSON-RPC 2.0 messages
        /// * GET requests for SSE streams (with Accept: text/event-stream)
        RejectNoMcp = 1,
    }
    impl TrafficMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PassThrough => "PASS_THROUGH",
                Self::RejectNoMcp => "REJECT_NO_MCP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PASS_THROUGH" => Some(Self::PassThrough),
                "REJECT_NO_MCP" => Some(Self::RejectNoMcp),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Mcp {
    const NAME: &'static str = "Mcp";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.mcp.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.mcp.v3.Mcp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.mcp.v3.Mcp".into()
    }
}
/// Parser configuration with method-specific rules.
/// This configuration allows overriding the default attribute extraction behavior for specific MCP methods.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParserConfig {
    /// Method-specific configurations.
    /// These rules override or supplement the default extraction logic for the specified methods.
    #[prost(message, repeated, tag = "1")]
    pub methods: ::prost::alloc::vec::Vec<parser_config::MethodConfig>,
}
/// Nested message and enum types in `ParserConfig`.
pub mod parser_config {
    /// A single attribute extraction rule.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AttributeExtractionRule {
        /// JSON path to extract (e.g., "params.name", "params.uri").
        /// The path is a dot-separated string representing the location of the field in the JSON payload.
        /// For example, "params.name" extracts the "name" field from the "params" object.
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
    }
    impl ::prost::Name for AttributeExtractionRule {
        const NAME: &'static str = "AttributeExtractionRule";
        const PACKAGE: &'static str = "envoy.extensions.filters.http.mcp.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule"
                .into()
        }
    }
    /// Configuration for a specific MCP method.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MethodConfig {
        /// Method name (e.g., "tools/call", "resources/read", "initialize").
        /// This matches the "method" field in the JSON-RPC request.
        #[prost(string, tag = "1")]
        pub method: ::prost::alloc::string::String,
        /// Attributes to extract for this method.
        /// If empty, no attributes will be extracted for this method beyond the default ones (jsonrpc, method).
        #[prost(message, repeated, tag = "2")]
        pub extraction_rules: ::prost::alloc::vec::Vec<AttributeExtractionRule>,
    }
    impl ::prost::Name for MethodConfig {
        const NAME: &'static str = "MethodConfig";
        const PACKAGE: &'static str = "envoy.extensions.filters.http.mcp.v3";
        fn full_name() -> ::prost::alloc::string::String {
            "envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig"
                .into()
        }
    }
}
impl ::prost::Name for ParserConfig {
    const NAME: &'static str = "ParserConfig";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.mcp.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.mcp.v3.ParserConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.mcp.v3.ParserConfig".into()
    }
}
/// Per-route override configuration for MCP filter
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct McpOverride {
    /// Optional per-route traffic mode override
    #[prost(enumeration = "mcp::TrafficMode", tag = "1")]
    pub traffic_mode: i32,
    /// Optional per-route max request body size override.
    /// When set, this overrides the global max_request_body_size for this route.
    /// It defaults to 8KB (8192 bytes) and the maximum allowed value is 10MB (10485760 bytes).
    #[prost(message, optional, tag = "2")]
    pub max_request_body_size: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::UInt32Value,
    >,
}
impl ::prost::Name for McpOverride {
    const NAME: &'static str = "McpOverride";
    const PACKAGE: &'static str = "envoy.extensions.filters.http.mcp.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.http.mcp.v3.McpOverride".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.http.mcp.v3.McpOverride".into()
    }
}
