// This file is @generated by prost-build.
/// Validation configuration for reverse tunnel identifiers.
/// Validates the node ID and cluster ID extracted from reverse tunnel handshake headers
/// against expected values specified using format strings.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Validation {
    /// Format string to extract the expected node identifier for validation.
    /// The formatted value is compared against the `x-envoy-reverse-tunnel-node-id` header
    /// from the incoming handshake request. If they do not match, the connection is rejected
    /// with HTTP `403 Forbidden`.
    ///
    /// Supports Envoy's :ref:`command operators <config_access_log_command_operators>`:
    ///
    /// * `%DYNAMIC_METADATA(namespace:key)%`: Extract expected value from dynamic metadata.
    /// * `%FILTER_STATE(key)%`: Extract expected value from filter state.
    /// * `%DOWNSTREAM_REMOTE_ADDRESS%`: Use downstream connection IP address.
    /// * Plain strings: Use a static expected value.
    ///
    /// If empty, node ID validation is skipped.
    ///
    /// Example using dynamic metadata allowlist:
    ///
    /// .. code-block:: yaml
    ///
    /// ```text
    /// node_id_format: "%DYNAMIC_METADATA(envoy.reverse_tunnel.allowlist:expected_node_id)%"
    /// ```
    #[prost(string, tag = "1")]
    pub node_id_format: ::prost::alloc::string::String,
    /// Format string to extract the expected cluster identifier for validation.
    /// The formatted value is compared against the `x-envoy-reverse-tunnel-cluster-id` header
    /// from the incoming handshake request. If they do not match, the connection is rejected
    /// with HTTP `403 Forbidden`.
    ///
    /// Supports the same :ref:`command operators <config_access_log_command_operators>` as
    /// `node_id_format`.
    ///
    /// If empty, cluster ID validation is skipped.
    ///
    /// Example using filter state:
    ///
    /// .. code-block:: yaml
    ///
    /// ```text
    /// cluster_id_format: "%FILTER_STATE(expected_cluster_id)%"
    /// ```
    #[prost(string, tag = "2")]
    pub cluster_id_format: ::prost::alloc::string::String,
    /// Whether to emit validation results as dynamic metadata.
    /// When enabled, the filter emits metadata under the namespace specified by
    /// `dynamic_metadata_namespace` containing:
    ///
    /// * `node_id`: The actual node ID from the handshake request.
    /// * `cluster_id`: The actual cluster ID from the handshake request.
    /// * `validation_result`: Either `allowed` or `denied`.
    ///
    /// This metadata can be used by subsequent filters or for access logging.
    /// Defaults to `false`.
    #[prost(bool, tag = "3")]
    pub emit_dynamic_metadata: bool,
    /// Namespace for emitted dynamic metadata when `emit_dynamic_metadata` is `true`.
    /// If not specified, defaults to `envoy.filters.network.reverse_tunnel`.
    #[prost(string, tag = "4")]
    pub dynamic_metadata_namespace: ::prost::alloc::string::String,
}
impl ::prost::Name for Validation {
    const NAME: &'static str = "Validation";
    const PACKAGE: &'static str = "envoy.extensions.filters.network.reverse_tunnel.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.network.reverse_tunnel.v3.Validation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.network.reverse_tunnel.v3.Validation"
            .into()
    }
}
/// Configuration for the reverse tunnel network filter.
/// This filter handles reverse tunnel connection acceptance and rejection by processing
/// HTTP requests where required identification values are provided via HTTP headers.
/// \[\#next-free-field: 6\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReverseTunnel {
    /// Ping interval for health checks on established reverse tunnel connections.
    /// If not specified, defaults to `2 seconds`.
    #[prost(message, optional, tag = "1")]
    pub ping_interval: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    /// Whether to automatically close connections after processing reverse tunnel requests.
    ///
    /// * When set to `true`, connections are closed after acceptance or rejection.
    /// * When set to `false`, connections remain open for potential reuse.
    ///
    /// Defaults to `false`.
    #[prost(bool, tag = "2")]
    pub auto_close_connections: bool,
    /// HTTP path to match for reverse tunnel requests.
    /// If not specified, defaults to `/reverse_connections/request`.
    #[prost(string, tag = "3")]
    pub request_path: ::prost::alloc::string::String,
    /// HTTP method to match for reverse tunnel requests.
    /// If not specified (`METHOD_UNSPECIFIED`), this defaults to `GET`.
    #[prost(
        enumeration = "super::super::super::super::super::config::core::v3::RequestMethod",
        tag = "4"
    )]
    pub request_method: i32,
    /// Optional validation configuration for node and cluster identifiers.
    /// If specified, the filter validates the `x-envoy-reverse-tunnel-node-id` and
    /// `x-envoy-reverse-tunnel-cluster-id` headers against expected values extracted
    /// using format strings. Requests that fail validation are rejected with HTTP `403 Forbidden`.
    #[prost(message, optional, tag = "5")]
    pub validation: ::core::option::Option<Validation>,
}
impl ::prost::Name for ReverseTunnel {
    const NAME: &'static str = "ReverseTunnel";
    const PACKAGE: &'static str = "envoy.extensions.filters.network.reverse_tunnel.v3";
    fn full_name() -> ::prost::alloc::string::String {
        "envoy.extensions.filters.network.reverse_tunnel.v3.ReverseTunnel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/envoy.extensions.filters.network.reverse_tunnel.v3.ReverseTunnel"
            .into()
    }
}
