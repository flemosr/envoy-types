// This file is @generated by prost-build.
/// The Network External Processing filter allows an external service to process raw TCP/UDP traffic
/// in a flexible way using a bidirectional gRPC stream. Unlike the HTTP External Processing filter,
/// this filter operates at the L4 (transport) layer, giving access to raw network traffic.
///
/// The filter communicates with an external gRPC service that can:
///
/// * Inspect traffic in both directions
/// * Modify the network traffic
/// * Control connection lifecycle (continue, close, or reset)
///
/// By using the filter's processing mode, you can selectively choose which data
/// directions to process (read, write or both), allowing for efficient processing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkExternalProcessor {
    /// The gRPC service that will process network traffic.
    /// This service must implement the NetworkExternalProcessor service
    /// defined in the proto file /envoy/service/network_ext_proc/v3/external_processor.proto.
    #[prost(message, optional, tag = "1")]
    pub grpc_service: ::core::option::Option<
        super::super::super::super::super::config::core::v3::GrpcService,
    >,
    /// By default, if the gRPC stream cannot be established, or if it is closed
    /// prematurely with an error, the filter will fail, leading to the close of connection.
    /// With this parameter set to true, however, then if the gRPC stream is prematurely closed
    /// or could not be opened, processing continues without error.
    /// \[\#not-implemented-hide:\]
    #[prost(bool, tag = "2")]
    pub failure_mode_allow: bool,
    /// Options for controlling processing behavior.
    /// \[\#not-implemented-hide:\]
    #[prost(message, optional, tag = "3")]
    pub processing_mode: ::core::option::Option<ProcessingMode>,
    /// Specifies the timeout for each individual message sent on the stream and
    /// when the filter is running in synchronous mode. Whenever
    /// the proxy sends a message on the stream that requires a response, it will
    /// reset this timer, and will stop processing and return an error (subject
    /// to the processing mode) if the timer expires. Default is 200 ms.
    /// \[\#not-implemented-hide:\]
    #[prost(message, optional, tag = "4")]
    pub message_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
}
/// Options for controlling processing behavior.
/// Filter will reject the config if both read and write are SKIP mode.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingMode {
    /// Controls whether inbound (read) data from the client is sent to the external processor.
    /// Default: STREAMED
    #[prost(enumeration = "processing_mode::DataSendMode", tag = "1")]
    pub process_read: i32,
    /// Controls whether outbound (write) data to the client is sent to the external processor.
    /// Default: STREAMED
    #[prost(enumeration = "processing_mode::DataSendMode", tag = "2")]
    pub process_write: i32,
}
/// Nested message and enum types in `ProcessingMode`.
pub mod processing_mode {
    /// Defines how traffic should be handled by the external processor.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataSendMode {
        /// Send the data to the external processor for processing whenever the data is ready.
        Streamed = 0,
        /// Skip sending the data to the external processor.
        Skip = 1,
    }
    impl DataSendMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Streamed => "STREAMED",
                Self::Skip => "SKIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STREAMED" => Some(Self::Streamed),
                "SKIP" => Some(Self::Skip),
                _ => None,
            }
        }
    }
}
