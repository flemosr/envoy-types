// This file is @generated by prost-build.
/// The Network External Processing filter allows an external service to process raw TCP/UDP traffic
/// in a flexible way using a bidirectional gRPC stream. Unlike the HTTP External Processing filter,
/// this filter operates at the L4 (transport) layer, giving access to raw network traffic.
///
/// The filter communicates with an external gRPC service that can:
///
/// 1. Inspect traffic in both directions
/// 1. Modify the network traffic
/// 1. Control connection lifecycle (continue, close, or reset)
///
/// By using the filter's processing mode, you can selectively choose which data
/// directions to process (read, write or both), allowing for efficient processing.
/// \[\#next-free-field: 7\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkExternalProcessor {
    /// The gRPC service that will process network traffic.
    /// This service must implement the NetworkExternalProcessor service
    /// defined in the proto file /envoy/service/network_ext_proc/v3/external_processor.proto.
    #[prost(message, optional, tag = "1")]
    pub grpc_service: ::core::option::Option<
        super::super::super::super::super::config::core::v3::GrpcService,
    >,
    /// By default, if the gRPC stream cannot be established, or if it is closed
    /// prematurely with an error, the filter will fail, leading to the close of connection.
    /// With this parameter set to true, however, then if the gRPC stream is prematurely closed
    /// or could not be opened, processing continues without error.
    /// \[\#not-implemented-hide:\]
    #[prost(bool, tag = "2")]
    pub failure_mode_allow: bool,
    /// Options for controlling processing behavior.
    /// \[\#not-implemented-hide:\]
    #[prost(message, optional, tag = "3")]
    pub processing_mode: ::core::option::Option<ProcessingMode>,
    /// Specifies the timeout for each individual message sent on the stream and
    /// when the filter is running in synchronous mode. Whenever
    /// the proxy sends a message on the stream that requires a response, it will
    /// reset this timer, and will stop processing and return an error (subject
    /// to the processing mode) if the timer expires. Default is 200 ms.
    /// \[\#not-implemented-hide:\]
    #[prost(message, optional, tag = "4")]
    pub message_timeout: ::core::option::Option<
        super::super::super::super::super::super::google::protobuf::Duration,
    >,
    #[prost(string, tag = "5")]
    pub stat_prefix: ::prost::alloc::string::String,
    /// Options related to the sending and receiving of dynamic metadata.
    #[prost(message, optional, tag = "6")]
    pub metadata_options: ::core::option::Option<MetadataOptions>,
}
/// Options for controlling processing behavior.
/// Filter will reject the config if both read and write are SKIP mode.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingMode {
    /// Controls whether inbound (read) data from the client is sent to the external processor.
    /// Default: STREAMED
    #[prost(enumeration = "processing_mode::DataSendMode", tag = "1")]
    pub process_read: i32,
    /// Controls whether outbound (write) data to the client is sent to the external processor.
    /// Default: STREAMED
    #[prost(enumeration = "processing_mode::DataSendMode", tag = "2")]
    pub process_write: i32,
}
/// Nested message and enum types in `ProcessingMode`.
pub mod processing_mode {
    /// Defines how traffic should be handled by the external processor.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataSendMode {
        /// Send the data to the external processor for processing whenever the data is ready.
        Streamed = 0,
        /// Skip sending the data to the external processor.
        Skip = 1,
    }
    impl DataSendMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Streamed => "STREAMED",
                Self::Skip => "SKIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STREAMED" => Some(Self::Streamed),
                "SKIP" => Some(Self::Skip),
                _ => None,
            }
        }
    }
}
/// The MetadataOptions structure defines options for sending dynamic metadata. Specifically,
/// which namespaces to send to the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataOptions {
    /// Describes which typed or untyped dynamic metadata namespaces to forward to
    /// the external processing server.
    #[prost(message, optional, tag = "1")]
    pub forwarding_namespaces: ::core::option::Option<
        metadata_options::MetadataNamespaces,
    >,
}
/// Nested message and enum types in `MetadataOptions`.
pub mod metadata_options {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetadataNamespaces {
        /// Specifies a list of metadata namespaces whose values, if present,
        /// will be passed to the ext_proc service as an opaque *protobuf::Struct*.
        #[prost(string, repeated, tag = "1")]
        pub untyped: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Specifies a list of metadata namespaces whose values, if present,
        /// will be passed to the ext_proc service as a *protobuf::Any*. This allows
        /// envoy and the external processing server to share the protobuf message
        /// definition for safe parsing.
        #[prost(string, repeated, tag = "2")]
        pub typed: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
